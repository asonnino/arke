
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FLAGS
%
\newif\iffull
\newif\ifnotes
\newif\iflater


\fulltrue
% \fullfalse


\notestrue
% \notesfalse

\latertrue
% \laterfalse

\synctex=1

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This package goes first because it checks all syntax for mistakes and some old-fashioned LaTeX commands.
\RequirePackage[l2tabu, orthodox]{nag}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[11pt,letterpaper]{article}
\usepackage[left=1in,right=1in,top=1in,bottom=1in,includefoot]{geometry}
\usepackage[usenames,table,dvipsnames]{xcolor}
\usepackage{amsfonts,amsmath,amssymb,amsthm}
\usepackage[utf8]{inputenc}
\usepackage{csquotes}
\usepackage[giveninits,backend=biber,style=alphabetic,maxnames=6]{biblatex}
\bibliography{references}
\renewcommand*{\bibfont}{\small}
\usepackage{xspace}
\usepackage{paralist}
\usepackage{enumitem}
  \setlist[itemize]{leftmargin=*}
  \setlist[enumerate]{leftmargin=*}
  \setlist[description]{leftmargin=*}
\usepackage{mleftright}
\usepackage{bbm}
\usepackage{bm}
\usepackage[scr=euler,frak=pxtx]{mathalfa}
\usepackage{breakcites}
\usepackage{microtype}
% \usepackage{numdef}
\usepackage{amsopn}
\usepackage{mathtools}
\usepackage{mathrsfs}
\usepackage{float}
\restylefloat{table}
\usepackage{makecell}
\usepackage[linesnumbered,ruled]{algorithm2e}
\usepackage{mdframed}
\usepackage{setspace}
\usepackage[section]{placeins}

\usepackage[utf8]{inputenc}
\setlength{\parindent}{0em}
\setlength{\parskip}{0.5em}


\usepackage{graphicx}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{construction}[theorem]{Construction}

\iffull
        \usepackage[\ifnotes draft, notes=true,\iflater later=true \else later=false \fi \else notes=false \fi]{dtrt}
        % \usepackage{hyperref}
\else
        \usepackage[notes=xxx]{dtrt}
        \usepackage{hyperref}
\fi
\usepackage[capitalize, nameinlink]{cleveref}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Allow equation environments to split across pages
\allowdisplaybreaks
% Don't split footnotes across pages
\interfootnotelinepenalty=10000

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% AUTHOR NOTES
%
\newcommand{\kobi}[1]{\dtcolornote[Kobi]{blue}{#1}}
\newcommand{\philipp}[1]{\dtcolornote[Philipp]{orange}{#1}}
\newcommand{\marek}[1]{\dtcolornote[Marek]{pink}{#1}}
\newcommand{\mikerah}[1]{\dtcolornote[Mikerah]{red}{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FORMATTING
%

\newcommand{\keywords}[1]{\bigskip\par\noindent{\textbf{Keywords\/}: #1}}

\newcommand{\doclearpage}{%
\iffull
\clearpage
\else
\fi
}

\newcommand{\DoQuote}[1]{``#1''}

\newcommand{\FormatAuthor}[2]{%
\begin{tabular}{c}
#1 \\ {\footnotesize\emailref{#2}}
\end{tabular}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\mathchardef\mhyphen="2D
\renewcommand\theadalign{bc}
\renewcommand\theadfont{\bfseries}
\renewcommand\theadgape{\Gape[4pt]}
\renewcommand\cellgape{\Gape[4pt]}
\providecommand{\sqbinom}{\genfrac{\lbrack}{\rbrack}{0pt}{}}
\DeclareMathOperator{\spn}{span}

\makeatletter
\newcommand{\pstep}[1]{%
  \par% ensure starting on a new paragraph
  \addvspace{\medskipamount}% some vertical space
  \textbf{#1}\enspace\ignorespaces
}
\makeatother


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SHORTCUTS

\newcommand{\GG}{\mathbb{G}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\key}{\mathsf{key}}
\newcommand{\val}{\mathsf{val}}
\newcommand{\str}{\mathsf{str}}
\newcommand{\pk}{\mathsf{pk}}
\newcommand{\sk}{\mathsf{sk}}
\newcommand{\acc}{\mathsf{acc}}
\newcommand{\sig}{\mathsf{sig}}
\newcommand{\addr}{\mathsf{addr}}
\newcommand{\voprf}{\mathsf{VOPRF}}
\newcommand{\pick}{\xleftarrow{\scriptscriptstyle \$}}
\newcommand{\salt}{\mathsf{salt}}
\newcommand{\aead}{\mathsf{AEAD}}
\newcommand{\kdf}{\mathsf{KDF}}
\newcommand{\mac}{\mathsf{MAC}}
\newcommand{\dleq}{\mathsf{DLEQ}}
\newcommand{\bls}{\mathsf{BLS}}
\newcommand{\bbls}{\mathsf{BBLS}}
\newcommand{\tbbls}{\mathsf{TBBLS}}
\newcommand{\keygen}{\mathsf{KeyGen}}
\newcommand{\sign}{\mathsf{Sign}}
\newcommand{\verify}{\mathsf{Verify}}
\newcommand{\blind}{\mathsf{Blind}}
\newcommand{\unblind}{\mathsf{Unblind}}
\newcommand{\combine}{\mathsf{Combine}}
\newcommand{\dkg}{\mathsf{DKG}}
\newcommand{\sys}{\textsc{Arke}\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[giveninits,backend=biber,style=alphabetic,maxnames=6]{biblatex}
\bibliography{references}

\title{\sys: Privacy-preserving Match-making and Messaging\\
{\large Technical note}
}
\author{Kobi Gurkan and Philipp Jovanovic}
\date{\today}

\begin{document}

\maketitle

\section{Introduction}

%In many systems it is desirable for usability to use human-memorable strings,
%such as phone numbers, email addresses, or Twitter handles, to identify
%participants. Public key infrastructure binds these identifiers to cryptographic
%credentials and allows for the management of these bindings including their
%creation, distribution storage, and revocation, enabling participants to
%establish secure communicating channels.

Celo's mission is to build an inclusive financial system with a seamless user
experience on mobile phones. To maximize user friendliness, one of Celo's main
goals thereby is to enable users to discover each others cryptocurrency accounts
only via their phone numbers. To realize such a user discovery feature
traditional services often force their users to upload all of their contacts to
a centralized server which is obviously undesirable for a decentralized
cryptocurrency. Another approach could be to utilize Celo's blockchain to do the
matching between phone numbers and cryptocurrency accounts. However, if the
binding between phone numbers and cryptocurrency accounts is done in an obvious
manner, then this can easily lead to privacy and security issues: Since phone
numbers are not secret and Celo's blockchain is publicly accessible, anybody
could check whether a given user has an account on Celo, uncover with whom they
transacted, and perhaps even use the gathered information to mount
spear-phishing attacks.  One approach to mitigate this problem is to obfuscate
this binding and rate-limit the amount of discovery requests users can make.
Unfortunately, this impacts the user experience as honest users might not be
able to discover all of their contacts. Rate-limiting also does not prevent
motivated adversaries from mounting Sybil attacks by creating fake accounts and
thereby getting additional discovery requests.

In this paper we introduce $\sys$\footnote{In Greek mythology $\sys$ is the
  messenger of the Titans.}, a system that addresses the above challenges enabling
users to decide who is and who is not allowed to find their cryptocurrency
accounts. $\sys$ therefore provides a privacy-preserving match-making service
enabling its users to establish end-to-end encrypted communication channels over
which they can exchange details about their cryptocurrency accounts (or any
other information) in a secure and private manner.

The rest of the paper is structured as follows: We first recall some
cryptographic building blocks in Section~\ref{sec:preliminaries} and then
present \sys our privacy-preserving match-making and messaging architecture in
Section~\ref{sec:architecture}.


\section{Preliminaries}\label{sec:preliminaries}

Let $E$ denote a pairing-friendly curve over $\ZZ_q$ equipped with a bilinear
pairing $e: \GG_1 \times \GG_2 \rightarrow \GG_T$. The pairing is efficiently
computable and non-degenerate. We denote by $g_1$, $g_2$, and $g_T$ the
canonical generators of $\GG_1$, $\GG_2$, and $\GG_T$, respectively, and by $H:
  \{0,1\}^{\ast} \rightarrow \{0,1\}^l$, $H_1: \{0,1\}^{\ast} \rightarrow \GG_1$,
and $H_2: \{0,1\}^{\ast} \rightarrow \GG_2$ hash functions. We treat $H$, $H_1$,
and $H_2$ as random oracles. Let $\lambda$ denote a security parameter.

\subsection{BLS Signatures and Variants}\label{sec:bls}

In this section we recall BLS signatures~\cite{boneh2001short} and several of
its variants. We start with the basic scheme.

\begin{definition}

  A BLS signature scheme $\bls$ has three algorithms $\keygen$, $\sign$, and
  $\verify$ and can be specified with public keys in $\GG_1$ and signatures in
  $\GG_2$ or the other way around with public keys in $\GG_2$ and signatures in
  $\GG_1$. We make use of both variants but describe only the second variant
  below.

  \begin{itemize}

    \item[] $\keygen(1^\lambda)$: Pick a random $x \pick \ZZ_q$. Set the secret
      key to $\sk \leftarrow x$ and the public key to $\pk \leftarrow g_2^x$.
      Output $\sk$ to the message signer and $\pk$ to the message signer and
      receiver.

    \item[] $\sign(\sk, m)$: Output $\sigma \leftarrow H_1(m)^\sk \in
        \mathbb{G}_1$ as the signature.

    \item[] $\verify(\pk, m, \sigma)$: If $e(\sigma, g_2) = e(H_1(m), \pk)$
      return $1$ (for \emph{accept}) and $0$ (for \emph{reject}) otherwise.

  \end{itemize}

\end{definition}

Next we recall blind BLS signatures~\cite{boldyreva2003threshold} which prevent
signers from learning details about the message that they sign.

\begin{definition}

  A blind BLS signature scheme $\bbls$ consists of five algorithms $\keygen$,
  $\blind$, $\sign$, $\unblind$, $\verify$, and is defined as follows:

  \begin{itemize}

    \item[] $\keygen(1^\lambda)$: Compute $(\sk, \pk) \leftarrow
        \bls.\keygen(1^\lambda)$. Output $\sk$ to the message signer and $\pk$
      to message signer and receiver.

    \item[] $\blind(m)$: Pick a random $r \pick \ZZ_q$. Output $\sigma_r
        \leftarrow H_1(m)^r \in \GG_1$ and $r$.

    \item[] $\sign(\sk, \sigma_r)$: Output $\widehat{\sigma} \leftarrow
        \sigma_r^\sk \in \GG_1$ as the blinded signature.

    \item[] $\unblind(\pk, r, \widehat{\sigma})$: Output $\sigma \leftarrow
        \widehat{\sigma}^{r^{-1}} \in \GG_1$ as the unblinded signature.

    \item[] $\verify(\pk, m, \sigma):$ Output $\bls.\verify(\pk, m, \sigma))$.

  \end{itemize}

\end{definition}


As the last variant we recall $(t,n)$-threshold blind BLS
signatures~\cite{boldyreva2003threshold} which enable any subset of at least $t$
out of $n$ participants to jointly issue blind BLS signatures. The goal thereby
is to remove single points of failure and ensure security even in the presence
of active adversaries that can corrupt up to $f=t-1$ parties. Our construction
relies heavily on Shamir Secret Sharing-based primitives such as distributed key
generation ($\dkg$)~\cite{gennaro2006secure,kate2012distributed} to set up shared
keys and Lagrange interpolation to combine partial signatures. We refer the
reader to the literature for further details.

%In the special case where the secret sharing scheme is Shamir's Secret
%Sharing, in the combining step user $u$ calculates $\sum_{i=1}^{t+1} L_{j_i}
%\hat{\sigma_{j_i}}$ to receive $\sigma$, where $L_i$ is the unique degree
%$t$ Lagrange polynomial that has $L_i(i) = 1$ and $L_i(0)$ at the other $t$
%coordinates.

\begin{definition}

  A $(t,n)$-threshold blind BLS signature scheme $\tbbls$ consists of six
  $\keygen$, $\blind$, $\sign$, $\combine$, $\unblind$, $\verify$ algorithms and
  is defined as follows:

  \begin{itemize}

    \item[] $\keygen(1^\lambda)$: Participants $P_1, \dots, P_n$ jointly execute
      a $(t,n)$-$\dkg$ to jointly compute secret key shares $\sk_1, \dots,
        \sk_n$ and a public key $\pk$. Output $\sk_i$ and $\pk$ to $P_i$ and $\pk$
      to the message receiver.

    \item[] $\blind(m)$: Output $(\sigma_r, r) \leftarrow \bbls.\blind(m)$.

    \item[] $\sign(\sk_i, \sigma_r)$: As participant $P_i$ output
      $\widehat{\sigma_i} \leftarrow \sigma_r^{\sk_i} \in \GG_1$ as the blinded
      partial signature.

    \item[] $\combine(\widehat{\sigma_{j_1}}, \dots, \widehat{\sigma_{j_t}})$:
      Use Lagrange interpolation on a subset of $t$ blinded partial signatures
      $\widehat{\sigma_{j_1}}, \dots, \widehat{\sigma_{j_t}}$ to recover the
      full blinded signature $\widehat{\sigma}$.

    \item[] $\unblind(\pk, r, \widehat{\sigma})$: Output $\sigma \leftarrow
        \bbls.\unblind(\pk, r, \widehat{\sigma})$ as the unblinded signature.

    \item[] $\verify(\pk, m, \sigma):$ Output $\bbls.\verify(\pk, m, \sigma))$.

  \end{itemize}

\end{definition}

\subsection{Left/right-constrained PRFs}

The final construction we recall are left/right-constrained
PRFs~\cite{boneh2013constrained} which we use for identity-based non-interactive
key exchange (IB-NIKE).

\begin{definition}

  Let $F: \mathcal{K} \times \mathcal{X}^2 \rightarrow \mathcal{Y}$ be a PRF.
  For all $w \in \mathcal{X}$ we wish to support constrained keys $k_{w,
        \mathtt{LEFT}}$ that enable the evaluation of $F(k, (x,y))$ at all points $(w,
    y) \in \mathcal{X}^2$, that is, all points in which the left side is fixed to
  $w$. In addition, we want constrained keys $k_{w, \mathtt{RIGHT}}$ that fix
  the right hand side of $(x, y)$ to $w$. More precisely, for an element $w \in
    \mathcal{X}$ we define the two predicates $p_w^{(L)}, p_w^{(R)}: \mathcal{X}^2
    \rightarrow \{0, 1\}$ as

  \[ p_w^{(L)} == 1 \iff x = w \text{ and } p_w^{(R)} == 1 \iff y = w\]

  We say that $F$ supports left/right fixing if it is constrained with respect to
  the set of predicates

  $$P_{LR} = \left\{p_w^{(L)}, p_w^{(R)} : w \in \mathcal{X}\right\}$$

\end{definition}


\begin{definition}[\bf Pairing-based Left/right-constrained PRFs]

  Let $k \in \ZZ_p$ denote a secret key, then we define the pairing-based
  left/right-constrained PRF $F$ as $F(k, (x,y)) = e(H_1(x), H_2(y))^k$. For
  $(a, b)\in \mathcal{X}^2$ the constrained keys for the predicates
  $p_{a}^{(L)}$ and $p_{b}^{(R)}$ are $k_{a} = H_1(a)^k$ and $k_{b} = H_2(b)^k$,
  respectively.

\end{definition}



\section{Architecture}\label{sec:architecture}

%\philipp{Note to self: describe what we mean by privacy-preserving here (in
%particular that phone numbers included in queries do not leak to involved
%services).}

In this section we describe the architecture of \sys  showing how it enables users to discover each others cryptocurrency addresses without leaking their contacts to third-parties. Figure~\ref{fig:system} gives an overview of \sys showing the four main operations, \emph{setup}, \emph{key derivation}, \emph{write}, and \emph{read}, it supports.

% During setup users obtain cryptographic credentials that allow them to derive shared keys with arbitrary users and execute certain write and read operations later on. A write operation corresponds to enabling discovery of a cryptocurrency address and a read operation corresponds to discovering an address that has been set up before by another user. 

\begin{figure}[h]
  \centering
  \includegraphics[width=0.75\textwidth]{figures/arke-architecture}
  \caption{\small $\sys$ overview. 1) Users individually run a setup procedure
    with the discovery service to obtain a service signature on their blinded
    identifier (Section~\ref{sec:setup}). 2) Users derive locally shared keys with
    another participant using their unblinded service-signed identifier
    (Section~\ref{sec:key}). 3) Users utilize shared keys to write to a cache and
    enable discovery of their cryptocurrency address (Section~\ref{sec:write}). 4)
    Users utilize shared keys to read from the cache to discover cryptocurrency
    addresses published previously by other users (Section~\ref{sec:read}).}
  \label{fig:system}
\end{figure}

The system has the following actors and components:\footnote{For simplicity we
  describe all constructions in a ``centralized'' manner but note that all
  building blocks have corresponding distributed variants.}

\begin{itemize}

  \item Each \emph{user} $A$ has a key pair $(\sk_A, \pk_A) = (x, g^x)$ for some
        random $x \in \ZZ_q$. The cryptocurrency account of a user is of the form
        $(\acc_A, \pk_A, \addr_A)$ where $\acc_A$ is some (opaque) account
        identifier and $\addr_A = H(\pk_A)$ is its address. A user $A$ furthermore
        has a discovery identifier $n_A$ (which are phone numbers in our case) for
        which it obtains during registration two authentication tokens $t_{A,1,d} =
          H_1(n_A)^v \in \GG_1$ and $t_{A,2,d} = H_2(n_A)^v \in \GG_2$ from some of
        the validators in epoch $d$. We assume users know each others discovery
        identifiers but not their account identifiers.

  \item \emph{Validators} participate in the blockchain consensus and sign up
        users to the system. We denote by $(\sk_{V,d}, \pk_{V,1,d}, \pk_{V,2,d}) =
          (v, g_1^v, g_2^v)$ the (aggregate) keys of the validators in epoch $d$.

  \item The (distributed) \emph{discovery service} $S$ has (threshold) keys
        $(\sk_S, \pk_{S,1}, \pk_{S,2}) = (s, g_1^s, g_2^s)$ and helps users $A$ and
        $B$ to discover each others cryptocurrency addresses in a privacy-preserving
        way.

  \item The \emph{blockchain} manages user accounts as introduced above, the
        validator public keys $\pk_{V,1,d}$ and $\pk_{V,2,d}$, and the service
        public keys $\pk_{S,1}$ and $\pk_{S,2}$.

  \item The off-chain \emph{discovery cache} manages key-value pairs $(\key,
          \val)$ and is assumed to be untrusted. It can be set up on a centralized
        server or run in a distributed manner.


\end{itemize}

\subsection{Threat model}
\textcolor{red}{TODO: Define system behaviors of all the actors in the system, especially the cache}

\subsection{Setup}\label{sec:setup}

To participate in the discovery scheme, a user $A$ first has to run the
following setup procedure together with the discovery service $S$. We assume
user $A$ knows the service public keys $\pk_{S,1}$ and $\pk_{S,2}$. The setup
has to be done only once per user.

\begin{enumerate}

  \item Pick a random blinding value $a \pick \ZZ_p$ and send $t_{A,1,d}^{a}$,
        $t_{A,2,d}^{a}$, $H_1(n_A)^{a}$, $H_2(n_A)^{a}$, $\acc_A$, $\sig_A =
          \sign(\sk_A, \acc_A)$ and $d$ to the service $S$.

  \item Upon receiving $A$'s request, the service $S$ retrieves the user
        account $(\acc_A, \pk_A, \addr_A)$ and the validator keys $\pk_{V,1,d}$ and
        $\pk_{V,2,d}$ of the corresponding epoch $d$ from the blockchain. We should require that only validators from a recent epoch (e.g., the current one) will be considered.

  \item To authenticate $A$'s request, the service $S$ then checks whether the
        following equalities hold:

        \begin{enumerate}

          \item $\verify(\pk_A, \acc_A, \sig_A) = 1$

          \item $e(t_{A,1,d}^{a}, g_2) = e(H_1(n_A)^{a}, \pk_{V,2,d})$

          \item $e(g_1, t_{A,2,d}^{a}) = e(\pk_{V,1,d}, H_2(n_A)^{a})$

        \end{enumerate}

  \item If all of these checks succeed, $S$ returns $(H_1(n_A)^{a})^s$ and
        $(H_2(n_A)^{a})^s$ to $A$.

  \item User $A$ then verifies the response of $S$ by checking that the
        following equations hold:

        \begin{enumerate}

          \item $e(H_1(n_A)^{as}, g_2) = e(H_1(n_A)^{a}, \pk_{S,2})$

          \item $e(g_1, H_2(n_A)^{as}) = e(\pk_{S,1}, H_2(n_A)^{a})$

        \end{enumerate}

  \item If both checks succeed, $A$ removes the blinding factor $a$ to obtain
        $H_1(n_A)^{s}$ and $H_2(n_A)^{s}$.

\end{enumerate}



\subsection{Key Derivation}\label{sec:key}

To derive shared keys with another user $B$ via its identifier $n_B$, user $A$
executes (locally) the following steps:

\begin{enumerate}

  \item Evaluate the pairing-based left/right constrained PRF $F$ using
        $H_1(n_A)^{s}$, $H_2(n_A)^{s}$, $H_1(n_B)$ and $H_2(n_B)$ to obtain two
        seeds:

        \begin{enumerate}

          \item $s_{AB} = F_s(H_1(n_A), H_2(n_B)) = e(H_1(n_A)^s, H_2(n_B)) =
                  e(H_1(n_A), H_2(n_B))^s \in \GG_T$

          \item $s_{BA} = F_s(H_1(n_B), H_2(n_A)) = e(H_1(n_B), H_2(n_A)^s) =
                  e(H_1(n_B), H_2(n_A))^s \in \GG_T$

        \end{enumerate}

  \item Use these seeds to compute a shared symmetric encryption key $k$, a
        tag $t_{AB}$ for writing elements to the cache, and a tag $t_{BA}$ for
        reading elements from the cache as follows:

        \begin{enumerate}

          \item Secret key: $k = \kdf(s_{AB} \oplus s_{BA} )$

          \item Writing tag: $t_{AB} = H(s_{AB})$

          \item Reading tag: $t_{BA} = H(s_{BA})$

        \end{enumerate}

\end{enumerate}



\subsection{Write}\label{sec:write}

If user $A$ wants to enable discovery of its address $\addr_A$ for $B$, it uses
the secret key $k$ and the writing tag $t_{AB}$ to:

\begin{enumerate}

  \item Encrypt address $\addr_A$ to obtain the ciphertext $c_{AB} = \aead_{k}(\addr_A)$.

  \item Store $(\key_{AB}, \val_{AB}) = (t_{AB}, c_{AB})$ on the cache.

\end{enumerate}



\subsection{Read}\label{sec:read}

If user $A$ wants to discover address $\addr_B$ which $B$ had to enable
beforehand, it uses the secret key $k$ and the reading tag $t_{BA}$ to:

\begin{enumerate}

  \item Retrieve $(\key_{BA}, \val_{BA}) = (t_{BA}, c_{BA})$ from the cache.

  \item Decrypt the ciphertext $c_{BA}$ to obtain the address $\addr_B =
          \aead_{k}(c_{BA})$.

\end{enumerate}



\subsection{Notes}

\begin{itemize}

  \item The identifiers $n_A$ and $n_B$ are phone numbers in our use case but
        they could be arbitrary but unique, human-memorable identifiers such as
        email addresses, Twitter handles, etc.

  \item The validator-issued authentication tokens $t_{A,1,d}$ and $t_{A,2,d}$
        have to be kept secret otherwise anyone could impersonate user $A$.

  \item The blinded tokens $t_{A,1,d}^a$ and $t_{A,2,d}^a$ ensure that $S$
        cannot learn the phone numbers in $A$'s request.

        %$t_{A} = H(t_{A,1,e}^{a} \parallel t_{A,2,e}^{a})$ being posted on-chain
        %allows the discovery service to utilize more information about the user's
        %attestation status in the Celo blockchain. Going back from the the hash to
        %the identifier a user validated to Celo, the service can, for example, see
        %how many successful and failed validations the user had and score them
        %based on that. The service can then decide to allow only users with score
        %above a certain threshold.

  \item Instead of requiring the user to provide $\acc_A$, they can instead provide $f+1$ token pairs, where $f$ is the assumed maximum threshold of malicious validators.

  \item If the service $S$ is set up in a distributed manner using threshold
        cryptography then a proxy server can reconstruct the blinded values
        $H_1(n_A)^{as}$ and $H_2(n_A)^{as}$ from the partial ones $H_1(n_A)^{as_i}$
        and $H_2(n_A)^{as_i}$ and forward them to the user which saves the latter
        some computation and bandwidth.

  \item A user $A$ has to interact with the service $S$ only once to obtain
        $H_1(n_A)^s$ and $H_2(n_A)^s$ which enables them to derive shared secrets
        with an arbitrary other identifier (phone number) $n_B$ locally.

  \item Next to cryptocurrency addresses, this scheme also enables to exchange
        any other information securely between two clients in an asynchronous manner
        if necessary.

  \item Communication between $A$ and $B$ is authenticated, so an adversary modifying the messages of $A$ and $B$ deposited in the cache will be detected.

  \item TODO: Authentication to the cache helps to protect the cache against DoS.

  \item TODO: cite Pythia https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/everspaugh

\end{itemize}

\appendix

\section{Simplified architecture - with some problems}

We can consider a simplified architecture where users do not properly authenticate the contents of their hash. Specifically, we could allow users to ask the service to receive a signature on a blinded $H(n_A || n_B)$. This approach poses a few problems:

\begin{enumerate}
  \item Privacy - without authenticating that I own either $n_A$ or $n_B$, I can uncover that phone $n_A$ knows phone $n_B$, which is a privacy loss over what exists today.
  \item Scalability - the user has to perform a round of communication for every target phone number they wish to look before proceeding to do the encryption, where in the new protocol thereâ€™s one round of communication that allows you to derive all the pairs.
  \item Rate-limiting needed for privacy - in our main construction, rate-limiting is done to prevent overload on the service. In this simplified architecture, rate-limiting needs to be applied to prevent harvesting of pairs of phone numbers.
\end{enumerate}


\doclearpage
\printbibliography


\end{document}
