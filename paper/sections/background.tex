\section{Preliminaries} \label{sec:background}
	\paragraph{Notation} Let $\GG_1$, $\GG_2$ and $\GG_T$ be groups of prime order $q$ such that there exists an efficiently computable and non-degenerate bilinear map $e: \GG_1 \times \GG_2 \rightarrow \GG_T$.
	We denote by $g_1$, $g_2$, and $g_T$ the canonical generators of $\GG_1$, $\GG_2$, and $\GG_T$, respectively, and by $H: \{0,1\}^{\ast} \rightarrow \{0,1\}^l$, $H_1: \{0,1\}^{\ast} \rightarrow \GG_1$, and $H_2: \{0,1\}^{\ast} \rightarrow \GG_2$ hash functions.
	We treat $H$, $H_1$, and $H_2$ as random oracles. Let $\lambda$ denote a security parameter.

\subsection{Zero Knowledge Proofs}
	We make use of two types of zero knowledge proofs of knowledge (ZKPoK). 
	In both cases we consider non-interactive protocols.
	The generic interface for such protocols is defined below:
	
	\begin{definition}[Non-interactive ZKPoK]
		For a relation $\relation(\instance, \witness)$, a non-interactive ZKPoK is defined by three efficiently computable algorithms:
		\begin{itemize}
			\item $\zk.\setup(\pp) \rightarrow \pp_\zk$. Given some global public parameters $\pp$, output the $\zk$ public parameters $\pp_\zk$.
			\item $\zk.\prove(\pp_\zk, \instance, \witness) \rightarrow \pi$. Given the public parameters $\pp_\zk$ and instance-witness pair $(\instance, \witness) \in \relation$, output a proof $\pi$.
			\item $\zk.\verify(\pp_\zk, \instance, \pi) \rightarrow \{0, 1\}$. Given the public parameters, instance and proof, return $1$ if the proof is valid and $0$ otherwise.
		\end{itemize} 
		%
		The ZKPoKs that we use in \sysname have perfect completeness, zero-knowledge and simulation extractability. The latter is a strengthened notion of knowledge soundness, wherein the extractor must be successful even if the adversary is given access to simulated proofs.	
	\end{definition}

	\paragraph{Schnorr DLOG} For a group $\GG$ of prime order $q$, the Schnorr DLOG ZKPoK is a $\Sigma$-protocol for the relation 
	$$\relation_\dlog:= \left\{ ((x, y), \alpha): y = x^\alpha \right\}$$ 
	where $x, y \in \GG$ and $\alpha \in \ZZ_q$.

	\paragraph{ZKPoK for Hash Pre-images} We use a ZKPoK to keep users' identities private while still attesting that hashed values are correct. Let $\id$ be an identifier and $\alpha \in \ZZ_q$ a blinding factor, we define the relation $\relation_\ID$ as:
	$$\relation_\ID := \left\{ \left(\ID, (\id, \alpha)\right): \ID = \left(H_1(\id)^\alpha, H_2(\id)^\alpha \right) \right\}  $$
	For our benchmarks, we instantiate the ZKPoK for $\relation_\ID$ using the Groth16 zkSNARK \cite{groth2016size}.

\subsection{Distributed Key Generation}
 
	\paragraph{Key-expressible DKGs} A key-expressible DKG \cite{gurkan2021aggregatable} is a distributed key generation protocol which upholds a relaxed \emph{secrecy} property.
	Rather than require the existence of a simulator that outputs a target public key $\pk_1$, key-expressible DKGs only require that the simulator outputs a public key $\pk$ that can be expressed as a linear relation between the target key $\pk_1$ and a simulator-chosen key-pair $(\sk_2, \pk_2)$.
	As with classic DKGs, a key-expressible DKG involving $n$ participants is robust with respect to some threshold $t < n/2$ of malicious participants.
	
	Key-expressible DKGs can be used as a stand-in replacement for the key generation operation of certain protocols.
	In doing so, we obtain a threshold variant of the underlying protocol.
	Key-expressible DKGs preserve the security properties of the underlying protocol if that protocol is \emph{rekeyable} \cite{gurkan2021aggregatable}.

	\paragraph{Rekeyability} Informally, a protocol is said to be rekeyable if it is possible to transform objects (ciphertexts, signatures, etc...) that were formed using one set of keys into equivalent objects formed under a related set of keys.
	For example, a BLS signature under key $\sk_1$, $\sigma = H_1(m)^{\sk_1}$, can be transformed into a signature under the key $\alpha\sk_1 + \sk_2$ by computing $\sigma^\alpha \cdot H_1(m)^{\sk_2}$.
	A full formal definition is given in \cite{gurkan2021aggregatable}.


\subsection{Identity-Based Non-Interactive Key Exchange} \label{sec:idnike}

	\paragraph{Boneh-Waters ID-NIKE} We give a self-contained definition of the Boneh-Water ID-NIKE \cite{boneh2013constrained} adapted for our asymmetric pairing setting.
	
	\begin{definition}[Boneh-Waters ID-NIKE~\cite{boneh2013constrained}]
		The Boneh-Waters identity-based key exchange consists of three efficiently computable algorithms $\setup$, $\keygen$ and $\extract$ as follows:
		\begin{itemize}
			\item $\setup(\lambda)$: Choose a random $\msk \pick \ZZ_q$ and output $\msk$.
			\item $\extract(\msk, \id)$: compute $d_L = H_1(\id)^{\msk}$ and $d_R = H_2(\id)^{\msk}$. Output $sk_\id = (d_L, d_R)$
			\item $\sharedkey(sk_\id, \id')$: We assume that identifiers are lexicographically ordered. Output $k_{\id, \id'} = e(d_L, H_2(\id'))$ if $\id < id'$. Output $k_{\id, \id'} = e(H_1(\id'), d_R)$ if $\id > \id'$.
		\end{itemize}
		Note that $\sharedkey(\pp, sk_\id, \id') = \sharedkey(\pp, sk_\id', \id)$ for all $\id \neq \id'$ and $\pp$ generated by $\setup$.
	\end{definition}

	The security notion for such schemes is that of ``indistinguishability of shared keys" (IND-SK) and is formalised by Patterson and Srivinasan \cite{cryptoeprint:2007/453}.
	In the IND-SK game, an adversary can learn private keys for any identity or learn the shared symmetric key between any identity pairs by querying the $\extract$ and $\mathsf{Reveal}$ oracles respectively.
	At any moment, it may make a single query to a $\mathsf{Test}$ oracle for identities $\id_*$ and $\id'_*$.
	The oracle flips a bit $b$ and outputs $k_{\id_*, \id'_*}$ if $b = 0$ or a random element from $\GG_T$ if $b=1$.
	The adversary may still query the other two oracles (except on values $\id_*$ and $\id'_*$) and must eventually decide whether $b=0$ or $b=1$.
	Importantly the adversary may not query $\mathsf{Test}$ on any identity pairs for which it queried $\mathsf{Reveal}$ nor any identity for which it queried $\extract$.

	Boneh and Waters show that the ID-NIKE above is secure under the decision bilinear Diffie Hellman assumption in the random oracle model \cite{boneh2013constrained}.
	
\subsection{Authenticated Encryption with Associated Data (AEAD)}

	Authenticated Encryption with Associated Data (AEAD) is a symmetric key primitive that encrypts and authenticates a message.
	Furthermore, senders may choose to associate context data to the ciphertext in a way that is cryptographically binding.
	An AEAD scheme is defined by the following algorithms:
	
	\begin{itemize}
		\item $\aead.\enc_k(m, d) \rightarrow (c, \aeadtag)$. 
			Given a key $k$, message $m$ and associated data $d$, encrypt $m$ to produce the ciphertext $c$.
			Authenticate the associated data and ciphertext to produce a tag $\aeadtag$. 
			Output $(c, \aeadtag)$.
		\item $\aead.\dec_k(c, \aeadtag) \rightarrow m'$. 
			Given a key $k$, ciphertext $c$ and associated data $\aeadtag$, verify the authenticity of the associated data and ciphertext. 
			If the verification rejects, output $m' \leftarrow \perp$. 
			Otherwise decrypt $c$ and output $m' \leftarrow m$.
	\end{itemize}



