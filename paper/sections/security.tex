\section{Security} \label{sec:security}
We argue that \sysname satisfies the security and privacy properties defined in \Cref{sec:properties} under the assumptions defined in \Cref{sec:assumptions}.

\subsection{Key Derivation Security} \label{sec:key-derivation-security}
The security of the \sysname key derivation protocol (\Cref{sec:key-derivation}) relies on assumption~\ref{as:crypto} (cryptography) defined in \Cref{sec:assumptions}.
%
The correctness of the key derivation process is essential to ensure the \emph{termination} properties of \sysname (\Cref{sec:termination}), and its privacy property are essential to guarantee \emph{validity} (\Cref{sec:validity}) and \emph{unlinkability} (\Cref{sec:unlinkability}).

\begin{theorem}[Key Derivation Correctness] \label{th:key-derivation-correctness}
    Two correct users $A$ and $B$ running the \sysname key derivation protocol (\Cref{sec:key-derivation}) with each other's username derive the same shared key $k$ and tags $t_{AB}$ and $t_{BA}$.
\end{theorem}
\begin{proof}
    \missing{Crypto proof}
\end{proof}

\begin{theorem}[Key Derivation Privacy] \label{th:key-derivation-privacy}
    At the end of the \sysname key derivation protocol (\Cref{sec:key-derivation}), only user $B$ and user $C$ learn their shared key $k_{BC}$ and the tags $t_{BC}$ and $t_{CB}$.
\end{theorem}
\begin{proof}
    \missing{Crypto proof}
\end{proof}


\subsection{Validity} \label{sec:validity}
The validity of \sysname relies on assumption~\ref{as:bft} (BFT) and assumption~\ref{as:crypto} (cryptography)  defined in \Cref{sec:assumptions}. \sysname can avoid relying on the BFT assumption for validity if we augment \Cref{alg:process-cert} (\Cref{sec:store-operations}) to (re-)run Check (\ref{alg:process-tx}.1) of \Cref{alg:process-tx} upon processing certificates (see \Cref{sec:store-operations}).

\paragraph{Authenticated writes}
We start by showing that users can only update the \sysname store at locations associated with their own username. That is, malicious users cannot interfere with the discovery protocol of other users.

\begin{lemma} \label{th:autenticated-tx-processing}
    No correct storage authority issues a vote $\vote$ over a transaction $\tx$ writing the \sysname store at a location $\key_{BC}=g_1^{t_{BC}}$ if the transaction's author does not know $t_{BC}$.
\end{lemma}
\begin{proof}
    Check (\ref{alg:process-tx}.1) of \Cref{alg:process-tx} requires the user to prove knowledge of $t_{BC}$ (through a digital signature); otherwise $\tx$ is ignored and the protocol returns an error.
\end{proof}

\begin{lemma} \label{th:authenticated-vote-generation}
    No correct storage authority issues a vote $\vote$ over a transaction $\tx$ generated by user $A$ (known by username $n_A$) writing the \sysname store at a location $\key_{BC}$ derived from the usernames $n_B$ (of user $B$) and $n_C$ (of user $C$), with $n_A \neq n_B \neq n_C$.
\end{lemma}
\begin{proof}
    Let's assume a correct authority issues a vote $\vote$ over $\tx$ writing the \sysname store at a location $\key_{BC}=g_1^{t_{BC}}$.
    %
    The privacy property of the \sysname key-derivation protocol (\Cref{th:key-derivation-privacy}) along with the collision-resistance of the hash-function $H$ (assumption~\ref{as:crypto}, see \Cref{sec:key-derivation}) ensures only users $B$ and $C$ can obtain $t_{BC}$.
    %
    As a result, user $A$ generated $\tx$ without the knowledge of $t_{BC}$ and a correct authority issued $\vote$ over $\tx$. This is however a direct contradiction of \Cref{th:autenticated-tx-processing}.
\end{proof}

\begin{theorem}[Authenticated Writes] \label{th:autenticated-writes}
    No user $A$ (known by username $n_A$) can generate a transaction $\tx$ that updates the store of correct storage authorities at a location $\key_{BC}$ derived from the usernames $n_B$ (of user $B$) and $n_C$ (of user $C$), with $n_A \neq n_B \neq n_C$.
\end{theorem}
\begin{proof}
    Let's assume a correct storage authority updates its storage at location $\key_{BC}$ as specified by $\tx$.
    %
    The \sysname store is only updated by \Cref{alg:process-cert} (\Cref{alg:line:update-store}) upon processing a valid certificate (Check (\ref{alg:process-cert}.1)). User $A$ thus obtains a valid certificate $\cert$ over $\tx$.
    %
    The BFT assumption (assumption~\ref{as:bft}, see \Cref{sec:assumptions}) ensures there are at most $f$ Byzantine authorities; user $A$ thus obtained at least $f+1$ votes over $\tx$ from correct storage authorities. This is however a direct contradiction of \Cref{th:authenticated-vote-generation} (ensuring that no correct authorities issue a vote over $\tx$).
\end{proof}

\paragraph{Replay prevention}
\Cref{th:autenticated-writes} ensures that no malicious user $A$ can generate a transaction to update the \sysname at locations unrelated with its username. We now show \sysname withstands replays of old certificates (generated by correct users). This is particularly important as the storage authorities may drop part of their $\lockdb$ store upon cleanup (\Cref{sec:epoch-change}).

\begin{theorem}[Deliver-Once]
    Once a correct storage authority processes a (valid) certificate $\cert$, it does not update its $\lockdb$ storage with a certificate $\cert'$ older then $\cert$.
\end{theorem}
\begin{proof}
    Let's assume a storage authority stores $\cert'$ in its $\lockdb$ store (\Cref{{alg:line:update-store}} of \Cref{alg:process-cert}) after it processed $\cert$.
    %
    Since $\cert'$ is older than $\cert$, it follows that either (i) $\epoch{\cert} > \epoch{\cert'}$, or (ii) $\version{\cert} > \version{\cert'}$.
    %
    In case (i), Check (\ref{alg:process-cert}.3) of \Cref{alg:process-cert} ensures the authority stops processing $\cert'$ and returns an error.
    %
    In case (ii), Check (\ref{alg:process-cert}.4) of \Cref{alg:process-cert} ensures the authority ignores $\cert'$ and does not update its $\lockdb$ storage.
    %
    As a result, there are no scenarios where a correct storage authority updates its $\lockdb$ with $\cert'$ after processing $\cert$, hence a contradiction.
\end{proof}

\paragraph{Authenticated credentials issuance}
We finally show that users can only obtain long-term credential (by running the setup phase \Cref{sec:setup}) over a username that has been attested by a KYC provider. Furthermore, the KYC provider can only successfully attest to usernames it generated.

\begin{theorem}[KYC Impersonation]
    No KYC provider $R$ can trick the key authorities to issue long-term credentials over a username $n_A$ generated by a KYC authority $R' \neq R$.
\end{theorem}
\begin{proof}
    \missing{Crypto proof}
\end{proof}

\begin{theorem}[Authorized Credentials Issuance]
    No user $A$ obtains the long-term credentials $H_1(n_A)^s$ and $H_2(n_A)^s$ over username $n_A$ without the attestation of the KYC provider that generated $n_A$.
\end{theorem}
\begin{proof}
    \missing{Crypto proof}
\end{proof}


\subsection{Consistency} \label{sec:consistency}
We show the consistency properties of \sysname described in \Cref{sec:properties}, namely \emph{write consistency} and \emph{read consistency}. These properties heavily rely on assumption~\ref{as:bft} (BFT), assumption~\ref{as:crypto} (cryptography), and assumption~\ref{as:clock} (roughly synchronized clocks) defined in \Cref{sec:assumptions}.
%
The lemmas and theorems of this section implicitly assumes that no adversary can forge vote (assumption~\ref{as:bft} (cryptography)).

\begin{lemma}[BCB Consistency] \label{th:bcb-consistency}
    No two conflicting transactions, namely transactions sharing the same storage location $\key$, version $\Version$, and epoch $\Epoch$, are certified.
\end{lemma}
\begin{proof}
    The proof of this lemma directly follows from the consistency property of Byzantine consistent broadcast (BCB) over the label $(\key, \Version, \Epoch)$~\cite{cachin2011introduction}.
    %
    Let's assume two conflicting transactions $\tx_A$ and $\tx_B$ taking as input the same storage location $\key$ with version $\Version$ are certified during the same epoch $\Epoch$.
    %
    Then $f+1$ correct storage authority performed (\ref{alg:process-tx}.3), Check (\ref{alg:process-tx}.4), and Check (\ref{alg:process-tx}.5) of \Cref{alg:process-tx} and produced $\vote_A$ over $\tx_A$; and $f+1$ correct storage authority did the same and produced $\vote_B$ ove $\tx_B$.
    %
    Correct storage authorities reject transactions for older epochs (Check (\ref{alg:process-tx}.3)) and with version older than their latest certificate (Check (\ref{alg:process-tx}.4)). Both $\tx_A$ and $\tx_B$ thus contain the current epoch and a version higher than the latest certificate known to the authority.
    %
    Finally, a correct storage authority performs check (\ref{alg:process-tx}.5) and does not successfully process both (conflicting) $\tx_A$ and $\tx_B$; it instead returns an error at \Cref{alg:line:no_conflict}. As a result, a set of $f+1$ correct storage authority produced $\vote_A$ but not $\vote_B$, and a distinct set of $f+1$ correct storage authority produced $\vote_B$ but not $\vote_A$.
    %
    Hence there should be $f+1+f+1=2f+2$ correct storage authority additionally to the $f$ byzantine. However $N=3f+1 < 3f+2$ hence a contradiction.
\end{proof}

\Cref{th:bcb-consistency} operates over the label $(\key, \Version, \Epoch)$ rather than only $(\key, \Version)$ because check (\ref{alg:process-tx}.5) of \Cref{alg:process-tx} relies on the integrity of the votes stored in $\lockdb$. These votes may however be dropped upon epoch change (\Cref{sec:epoch-change}). There can thus exist multiple certificates with the same $(\key, \Version)$ but different epochs. This is not a problem because certificates carry their epoch number and are only valid for the current epoch (see Check (\ref{alg:process-cert}.3) of \Cref{alg:process-cert}).

\paragraph{Write consistency}
Write consistency intuitively ensures that correct storage authorities do not hold conflicting records.

\begin{theorem}[Write Consistency]
    No two correct storage authorities hold conflicting certificates in their $\lockdb$ store. That is, two certificates sharing the same storage location, version, and epoch.
\end{theorem}
\begin{proof}
    Let's assume the $\lockdb$ store of two correct storage authorities $S$ and $S'$ respectively hold conflicting the certificates $\cert$ and $\cert'$.
    %
    Check (\ref{alg:process-cert}.1) ensures correct authorities only store valid certificates in their $\lockdb$ store. This implies that authority $S$ received the valid certificate $\cert$ and authority $S'$ received the valid (conflicting) certificate $\cert'$. \Cref{th:bcb-consistency} however ensures $\cert = \cert'$, hence a contradiction.
\end{proof}

\paragraph{Read consistency}
Read consistency intuitively ensures that two correct users attempting to read the same storage location do not read different values.

\begin{lemma}[Safe Cleanup] \label{th:read-deletion}
    No correct user reads the value $\val$ if at least one correct storage authority deletes $\val$ (upon cleanup).
\end{lemma}
\begin{proof}
    Let's assume a correct user reads $\val$ and one correct storage authority deletes $\val$.
    %
    A correct authority $S$ at epoch $e_s$ deletes a value $\val$ wrote at epoch $e_c$ when
    \begin{equation} \label{eq:delete-cond}
        e_s > E + e_c
    \end{equation}
    (where $E>0$ is a system parameter, see \Cref{sec:epoch-change}).
    %
    Check (\ref{alg:process-reply}.1) ensures correct users at epoch $e_u$ only read $\val$ if
    \begin{equation} \label{eq:read-cond}
        e_u < E + e_c
    \end{equation}
    %
    Furthermore, assumption~\ref{as:clock} (roughly synchronized clocks, see \Cref{sec:assumptions}) ensures that either
    \begin{equation} \label{eq:clock-assumption}
        e_u = e_s \text{, } e_u = e_s + 1 \text{, or } e_u = e_s - 1
    \end{equation}
    %
    Substituting \Cref{eq:clock-assumption} into \Cref{eq:delete-cond}, we (conservatively) find that authority $S$ deletes $\val$ when
    \begin{equation} \label{eq:delete-final-cond}
        e_u > E + e_c - 1
    \end{equation}
    %
    Combining \Cref{eq:read-cond} and \Cref{eq:delete-final-cond}, we find that a correct reader only reads $\val$ when $S$ deletes it if the two following conditions are both met:
    $$
        \begin{cases}
            e_u < E + e_c,  \text{ and } & \\
            e_u > E + e_c - 1            &
        \end{cases}
    $$
    There exist however no $e_u$ (and thus no $e_v$) for which both conditions hold, hence a contradiction.
\end{proof}

\begin{theorem}[Read Consistency]
    No two correct users sending a read transaction $\readtx$ for the same store location $\key$ read two different values $\val$ and $\val'$.
\end{theorem}
\begin{proof}
    Let's assume two correct users read the different values $\val$ and $\val'$ for the same store location $\key$.
    %
    Users only read values from (valid) certificates (\Cref{alg:line:read_cert} of \Cref{alg:process-reply}). As a result, one correct user read $\val$ while the other read $\val'$
    %
    This either implies that (i) there exist two correct and conflicting certificates over $\val$ and $\val'$ (which would be a contradiction of \Cref{th:bcb-consistency}), or (ii) that one user reads $\val'=\None$ after a correct authority deletes $\val'$ (which would be a contradiction of \Cref{th:read-deletion}).
\end{proof}

\subsection{Termination} \label{sec:termination}
We prove the termination (liveness) properties of \sysname described in \Cref{sec:properties}, namely \emph{write termination} and \emph{read termination}. These properties heavily rely on assumption~\ref{as:bft} (BFT), assumption~\ref{as:crypto} (cryptography), assumption~\ref{as:net} (network model), and assumption~\ref{as:clock} (roughly synchronized clocks) of \Cref{sec:assumptions}.
%
The termination properties only apply to \emph{correct} transactions and certificates defined in \Cref{def:correct-tx} and \Cref{def:correct-cert}, respectively.

\begin{definition}[Correct Write Transaction] \label{def:correct-tx}
    A correct transaction $\tx$ is valid (see \Cref{sec:store-operations}), contains the expected version, and does not non-equivocates (i.e., it is the only transaction over the triple $(\key, \Version, \Epoch)$).
\end{definition}

\begin{definition}[Correct Certificate] \label{def:correct-cert}
    A correct certificate $\cert$ is is valid (see \Cref{sec:store-operations}) and contains the highest version number generated for the specific store entry it writes.
\end{definition}

\paragraph{Writer termination}
Writer termination intuitively means that a correct writer can eventually update the storage authorities to make its key discoverable. The writer starts this process by submitting a transaction $\tx$ manifesting its intent to make its key discoverable. \sysname consider the key discoverable when $f+1$ correct storage authorities hold a certificate over $\tx$.

The following lemmas assume the existence of a correct synchronizer. As discussed in \Cref{sec:discovery} such synchronizer does not need the knowledge of any secret and can be implemented by the writer or by correct storage authorities (in which case its existence is implied by assumption~\ref{as:bft} (BFT) of \Cref{sec:assumptions}).

\begin{lemma}[\tx Availability] \label{th:synchronizer-learns-tx}
    If a correct user submits a transaction $\tx$ to the storage authorities, a correct synchronizer eventually learns $\tx$.
\end{lemma}
\begin{proof}
    A correct user terminates the process of submitting $\tx$ when a set $\{S\}$ of $2f+1$ storage authorities receive $\tx$ (see \Cref{sec:protocol-overview}).
    %
    The synchronizer queries all ($3f+1$) storage authorities and waits for the first $2f+1$ replies. Since at most $f$ of those authorities are Byzantine (assumption~\ref{as:bft} (BFT), see \Cref{sec:assumptions}), the synchronizer is guaranteed to receive a set $\{S'\}$ of $2f+1$ replies.
    %
    By quorum intersection, at least one correct authority is part of both $\{S\}$ and $\{S'\}$ and thus delivers $\tx$ to the synchronizer.
\end{proof}

\begin{lemma} \label{th:synchronizer-obtain-cert}
    During periods of synchrony, a correct synchronizer can obtain a certificate $\cert$ over a correct transaction $\tx$.
\end{lemma}
\begin{proof}
    The proof of this lemma directly follows from the termination property of Byzantine consistent broadcast (BCB)~\cite{cachin2011introduction}.
    %
    The synchronizer first disseminates $\tx$ to all ($3f+1$) storage authorities.
    %
    Since $\tx$ is valid, Check (\ref{alg:process-tx}.1) succeeds.
    %
    Check (\ref{alg:process-tx}.2) always passes for the first copy of $\tx$ received by the authority (at any given time).
    %
    During periods of synchrony, assumption~\ref{as:net} (network) and assumption~\ref{as:clock} (roughly synchronized clocks) ensure Check (\ref{alg:process-tx}.3) succeeds; indeed correct authorities receive $\tx$ during the same epoch $\Epoch$ of its generation and remain sufficiently long in epoch $\Epoch$.
    %
    Check (\ref{alg:process-tx}.4) passes since $\tx$ contains the next expected version number.
    %
    Finally, correct transactions do not equivocate; thus $\tx$ is the first and only transaction accessing a particular storage location, and always passes Check (\ref{alg:process-tx}.5).
    %
    Since all checks pass, the BFT assumption (assumption~\ref{as:bft} (BFT)) ensures that at least $2f+1$ authorities reply with a vote $\vote$ over $\tx$. The synchronizer then locally aggregates these votes into a certificate $\cert$.
\end{proof}

\begin{lemma}\label{th:authorities-hold-cert}
    During periods of synchrony, at least $f+1$ correct storage authorities at epoch $\Epoch$ can hold a correct certificate $\cert$ over a transaction $\tx$ generated at epoch $\Epoch$ if a correct synchronizer holds $\cert$.
\end{lemma}
\begin{proof}
    The synchronizer repetitively disseminates $\cert$ to all ($3f+1$) storage authorities until it receives an acknowledgement from a set $\{S\}$ of $2f+1$ authorities.
    %
    Correct authorities always acknowledge the receipt of $\cert$. Indeed, Check (\ref{alg:process-cert}.1) passes since $\cert$ is valid and Check (\ref{alg:process-cert}.2) always passes for the first copy of $\cert$ received by the authority (at any given time). During periods of synchrony, assumption~\ref{as:net} (network) ensures Check (\ref{alg:process-tx}.3) succeeds; indeed the authorities receive $\cert$ during epoch $\Epoch$. Finally, Check (\ref{alg:process-tx}.4) passes since $\cert$ is correct and thus contains the highest version generated for its store entry.
    %
    Since $\{S\}$ contains at most $f$ Byzantine authorities (assumption~\ref{as:bft}, BFT), the remaining $f+1$ storage authorities of $\{S\}$ are correct and thus hold $\cert$.
\end{proof}

\begin{theorem}[Writer Termination] \label{th:write-termination}
    During periods of synchrony, if a correct writer submits a correct transaction $\tx$ (generated at epoch $\Epoch$), at least $f+1$ correct storage authorities eventually receive a certificate $\cert$ over $\tx$.
\end{theorem}
\begin{proof}
    During periods of synchrony, assumption~\ref{as:net} (network) ensures a correct synchronizer manges to perform the following steps within the same epoch $\Epoch$; and assumption~\ref{as:clock} (roughly synchronized clocks) ensures correct authorities remain sufficiently long in epoch $\Epoch$.
    %
    (i) A correct synchronizer obtain $\tx$ after the correct writer submits it to the storage authorities (\Cref{th:synchronizer-learns-tx}).
    %
    (ii) The synchronizer obtains a certificate $\cert$ over $\tx$ (\Cref{th:synchronizer-obtain-cert}).
    %
    (iii) The synchronizer disseminates $\cert$ to the storage authorities; \Cref{th:synchronizer-obtain-cert} ensures a least $f+1$ correct storage authorities hold $\cert$.
\end{proof}

\Cref{th:write-termination} mentions that writer termination is only guaranteed during periods of synchrony where the synchronizer manages to complete the synchronization protocol within the epoch of the transaction's generation. Assumption~\ref{as:net} (network) ensures that a period of synchrony eventually happens; a correct user generates an submits its transaction every epoch until then. This is not a practical limitation as \sysname's epochs are long (e.g., 10 days) and the protocol is responsive~\cite{hotstuff} (i.e., it does not need to wait until the end of each epoch to make progress).

\paragraph{Reader termination}
Reader termination guarantees that a user $B$ can eventually discover the key of user $A$ if (i) user $A$ made its key discoverable to user $B$, and (ii) user $B$ knows the username $n_A$ of user $A$.

\begin{lemma} \label{th:can-read-val}
    During periods of synchrony, if $f+1$ correct storage authorities hold a certificate $\cert$ over the key values $(\key, \val)$ (with $\val \neq \None$), a user knowing $\key$ can eventually read $\val$.
\end{lemma}
\begin{proof}
    The user continuously queries all ($3f+1$) storage authorities at location $\key$ until it receives $2f+1$ valid replies (that is, replies passing Check (\ref{alg:process-reply}.1)).
    %
    Under assumption~\ref{as:bft} (BFT), quorum intersection ensures at least one of those replies originated from a correct storage authority holding $\cert$.
    %
    The user then parses $\cert$ to obtain $\val$. During periods of synchrony (assumption~\ref{as:net}, network), the steps above run before storage cleanup and thus $\val \neq \None$.
\end{proof}

\begin{theorem}[Read Termination] \label{th:reader-termination}
    During periods of synchrony, A correct user $B$ can eventually discover the key $\pk_A$ of user $A$ known by username $n_A$ if (i) user $A$ made $\pk_A$ discoverable to user $B$, and (ii) user $B$ knows the username $n_A$.
\end{theorem}
\begin{proof}
    From condition (i) it follows that user $A$ derived the shared key $k$ and the writing tag $t_{AB}$, and submitted a transaction $\tx$ to write the key-value
    $$(\key_{AB}, \val_{AB}) = (g_1^{t_{AB}}, \aead_k(\pk_A))$$
    to the storage authorities.
    %
    \Cref{th:write-termination} then ensures $f+1$ correct storage authorities hold a certificate $\cert$ over $\tx$.
    %
    Condition (ii) indicates that user $B$ knows $n_A$; \Cref{th:key-derivation-correctness} thus ensures user $B$ can also derive the same shared key $k$ and the writing tag $t_{AB}$; user $B$ can thus compute $\key_{AB} = g_1^{t_{AB}}$.
    %
    Under assumption~\ref{as:net} (network), \Cref{th:can-read-val} ensures user $B$ can use $\key_{AB}$ to eventually retrieve $\cert$ before storage cleanup.
    %
    Finally, user $B$ uses the shared $k$ to decrypt $\val_{AB} = \aead_k(\pk_A)$ (embedded into \cert) and recover $\pk_A$.
\end{proof}

\Cref{th:reader-termination} guarantees reader termination only during periods of synchrony. This assumption is necessary for the proofs since storage authorities clean up their storage after a fixed number of epochs. This assumption is however overly theoretical as store entries are only deleted after several months.

\paragraph{Key discovery termination}
\Cref{th:key-discovery-termination} argues that correct users eventually successes in running the setup phase (\Cref{sec:setup}) and obtain long-term credentials over a username they own.

\begin{theorem}[Key Discovery Termination] \label{th:key-discovery-termination}
    A correct user $A$ owning username $n_A$ can eventually receive the long-term credentials $(H_1(n_A)^s, H_2(n_A)^s)$.
\end{theorem}
\begin{proof}
    This theorem is proven by construction on the setup protocol described in details in \Cref{sec:setup-details}.
    %
    The user first proves ownership of $n_A$ and receives an attestation from the KYC provider (\Cref{alg:username-attestation}).
    %
    The user then continuously sends this attestation to all ($3f+1$) credentials authorities. Assumption~\ref{as:bft} (BFT) ensures the user eventually receives $2f+1$ partial long-term credential $\{(H_1(n_A)^{s_i}, H_2(n_A)^{s_i})\}, \; i \in [0,\dots,2f+1]$ (\Cref{alg:credentials-issuance}).
    %
    The user then aggregates those partial long-term credentials into a consolidated long-term credential $(H_1(n_A)^{s}, H_2(n_A)^{s})$ using lagrange interpolation (\Cref{sec:key-derivation}).
\end{proof}


\subsection{Unlinkability} \label{sec:unlinkability}
\missing{Crypto theorems}